import typing


class Macro:

    def __init__(self, expr: str):
        split = expr.split("=", 1)
        self.name = split[0]
        self.value = split[1] if len(split) == 2 else None

    def __repr__(self):
        return f"{type(self).__qualname__}({self.name}, value={self.value!r})"


T = typing.TypeVar("T")


class HeaderBuilder:

    def __init__(
        self,
        file: typing.TextIO,
        macros: typing.Iterable[Macro],
        logger: typing.Callable,
    ):
        self.__file = file
        self.__macros = {macro.name: macro.value for macro in macros}
        self.__logger = logger

    def main(self):
        """Do not override!"""
        guard = self.__module__.replace(".", "_")
        self.writelines(
            f"// auto-generated by {self.__module__}",
            f"#ifndef {guard}",
            f"#define {guard}",
            "",
        )
        self.build()
        self.writelines(
            "",
            f"#endif // {guard}",
        )

    def build(self):
        """Meant to be overridden."""
        pass

    def macro(
        self,
        name: str,
        type: typing.Callable[[str | None], T],
        default: T,
        *,
        override: bool = False,
        show: typing.Callable[[T], str] | bool = True,
    ) -> T:
        if not override and name in self.__macros:
            value = type(self.__macros[name])
        else:
            value = default

        if show is not False:
            if show is True:
                match value:
                    case int():
                        rep = str(int(value))
                    case str():
                        rep = value
                    case _:
                        rep = f'"{value}"'
            else:
                rep = show(value)

            self.writelines(f"#define {name} {rep}")

        return value

    def write(self, content: str):
        return self.__file.write(content)

    def writelines(self, *lines: str):
        """A newline character is added to every line."""
        self.__file.writelines(f"{line}\n" for line in lines)

    def info(self, *lines: str):
        self.__log("i", *lines)

    def ok(self, *lines: str):
        self.__log("+", *lines)

    def bad(self, *lines: str):
        self.__log("-", *lines)

    def warn(self, *lines: str):
        self.__log("!", *lines)

    def __log(self, c: str, *lines: str):
        lead = f"[{c}]"
        for line in lines:
            self.__logger(lead, line)
            lead = "..."
